/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare const enum _DynamicFlag {
  NONE = 0,
  REFERENCED = 1,
  NON_TEMPLATE = 2,
  INSERT = 4
}

export interface BaseIRNode {
  type: IRNodeTypes
}

export interface BlockIRNode {
  type: IRNodeTypes
  node?: object
  dynamic: IRDynamicInfo
  tempId: number
  effect: Array<IREffect>
  operation: Array<OperationNode>
  returns: Array<number>
  props?: SimpleExpressionNode
}

export declare function camelize(str: string): string

export interface CodegenOptions {
  /** * Generate source map?
   * @default false
   */
  sourceMap?: boolean
  /** * Filename for source map generation.
   * Also used for self-recursive reference in templates
   * @default 'index.jsx'
   */
  filename?: string
  templates?: Array<string>
}

export interface CompilerError extends SyntaxError {
  code: number
  loc?: SourceLocation
}

export interface CreateComponentIRNode {
  type: IRNodeTypes.CREATE_COMPONENT_NODE
  id: number
  tag: string
  props: Array<IRProps>
  slots: Array<IRSlots>
  asset: boolean
  root: boolean
  once: boolean
  dynamic?: SimpleExpressionNode
  parent?: number
  anchor?: number
}

export interface CreateNodesIRNode {
  type: IRNodeTypes.CREATE_NODES
  id: number
  once: boolean
  values: Array<SimpleExpressionNode>
}

export declare function createSimpleExpression(content: string, isStatic?: boolean | undefined | null, ast?: object | undefined | null, loc?: SourceLocation | undefined | null): SimpleExpressionNode

export interface DeclareOldRefIRNode {
  type: IRNodeTypes.DECLARE_OLD_REF
  id: number
}

export interface DirectiveIRNode {
  type: IRNodeTypes.DIRECTIVE
  element: number
  dir: DirectiveNode
  name: string
  builtin?: boolean
  asset?: boolean
  modelType?: 'text' | 'dynamic' | 'radio' | 'checkbox' | 'select'
}

export interface DirectiveNode {
  name: string
  exp?: SimpleExpressionNode
  arg?: SimpleExpressionNode
  modifiers: Array<SimpleExpressionNode>
  loc?: SourceLocation
}

export interface DirectiveTransformResult {
  key: SimpleExpressionNode
  value: SimpleExpressionNode
  modifier?: '.' | '^'
  runtimeCamelize?: boolean
  handler?: boolean
  handlerModifiers?: Modifiers
  model?: boolean
  modelModifiers?: Array<string>
}

export const EMPTY_EXPRESSION: SimpleExpressionNode

export declare const enum ErrorCodes {
  X_V_IF_NO_EXPRESSION = 28,
  X_V_ELSE_NO_ADJACENT_IF = 30,
  X_V_FOR_NO_EXPRESSION = 31,
  X_V_FOR_MALFORMED_EXPRESSION = 32,
  X_V_ON_NO_EXPRESSION = 35,
  X_V_SLOT_MIXED_SLOT_USAGE = 37,
  X_V_SLOT_DUPLICATE_SLOT_NAMES = 38,
  X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN = 39,
  X_V_SLOT_MISPLACED = 40,
  X_V_MODEL_NO_EXPRESSION = 41,
  X_V_MODEL_MALFORMED_EXPRESSION = 42,
  X_V_HTML_NO_EXPRESSION = 53,
  X_V_HTML_WITH_CHILDREN = 54,
  X_V_TEXT_NO_EXPRESSION = 55,
  X_V_TEXT_WITH_CHILDREN = 56,
  X_V_MODEL_ON_INVALID_ELEMENT = 57,
  X_V_MODEL_ARG_ON_ELEMENT = 58,
  X_V_MODEL_ON_FILE_INPUT_ELEMENT = 59,
  X_V_MODEL_UNNECESSARY_VALUE = 60,
  X_V_SHOW_NO_EXPRESSION = 61
}

export interface ForIRNode {
  source: SimpleExpressionNode
  value?: SimpleExpressionNode
  key?: SimpleExpressionNode
  index?: SimpleExpressionNode
  type: IRNodeTypes.FOR
  id: number
  keyProp?: SimpleExpressionNode
  render: BlockIRNode
  once: boolean
  component: boolean
  onlyChild: boolean
  parent?: number
  anchor?: number
}

export declare function getExpression(node: import('oxc-parser').Node): import('oxc-parser').Node

export declare function getLiteralExpressionValue(exp: SimpleExpressionNode): string | null

export interface GetTextChildIRNode {
  type: IRNodeTypes.GET_TEXT_CHILD
  parent: number
}

export declare function getTextLikeValue(node: import('oxc-parser').Node, excludeNumber?: boolean | undefined | null): string | null

export interface IfIRNode {
  type: IRNodeTypes.IF
  id: number
  condition: SimpleExpressionNode
  positive: BlockIRNode
  negative?: BlockIRNode | IfIRNode
  once?: boolean
  parent?: number
  anchor?: number
}

export type InsertionStateTypes =
  IfIRNode | ForIRNode | CreateComponentIRNode

export interface InsertNodeIRNode {
  type: IRNodeTypes.INSERT_NODE
  elements: Array<number>
  parent: number
  anchor?: number
}

export interface IRDynamicInfo {
  id?: number
  flags: number
  anchor?: number
  children: Array<IRDynamicInfo>
  template?: number
  hasDynamicChild?: boolean
  operation?: MyBox<OperationNode>
}

export declare const enum IRDynamicPropsKind {
  EXPRESSION = 0,
  ATTRIBUTE = 1
}

export interface IREffect {
  expressions: Array<SimpleExpressionNode>
  operations: Array<OperationNode>
}

export interface IRFor {
  source?: SimpleExpressionNode
  value?: SimpleExpressionNode
  key?: SimpleExpressionNode
  index?: SimpleExpressionNode
}

export type IRNode =
  OperationNode | RootIRNode

export declare const enum IRNodeTypes {
  ROOT = 'ROOT',
  BLOCK = 'BLOCK',
  SET_PROP = 'SET_PROP',
  SET_DYNAMIC_PROPS = 'SET_DYNAMIC_PROPS',
  SET_TEXT = 'SET_TEXT',
  SET_EVENT = 'SET_EVENT',
  SET_DYNAMIC_EVENTS = 'SET_DYNAMIC_EVENTS',
  SET_HTML = 'SET_HTML',
  SET_TEMPLATE_REF = 'SET_TEMPLATE_REF',
  INSERT_NODE = 'INSERT_NODE',
  PREPEND_NODE = 'PREPEND_NODE',
  CREATE_COMPONENT_NODE = 'CREATE_COMPONENT_NODE',
  SLOT_OUTLET_NODE = 'SLOT_OUTLET_NODE',
  DIRECTIVE = 'DIRECTIVE',
  DECLARE_OLD_REF = 'DECLARE_OLD_REF',
  IF = 'IF',
  FOR = 'FOR',
  GET_TEXT_CHILD = 'GET_TEXT_CHILD',
  CREATE_NODES = 'CREATE_NODES',
  SET_NODES = 'SET_NODES'
}

export interface IRProp {
  key: SimpleExpressionNode
  modifier?: '.' | '^'
  runtimeCamelize?: boolean
  handler?: boolean
  handlerModifiers?: Modifiers
  model?: boolean
  modelModifiers?: Array<string>
  values: Array<SimpleExpressionNode>
}

export type IRProps =
  IRPropsStatic | IRPropsDynamicAttribute | IRPropsDynamicExpression

export interface IRPropsDynamicAttribute {
  key: SimpleExpressionNode
  modifier?: '.' | '^'
  runtimeCamelize?: boolean
  handler?: boolean
  handlerModifiers?: Modifiers
  model?: boolean
  modelModifiers?: Array<string>
  values: Array<SimpleExpressionNode>
  kind: IRDynamicPropsKind.ATTRIBUTE
}

export interface IRPropsDynamicExpression {
  kind: IRDynamicPropsKind.EXPRESSION
  value: SimpleExpressionNode
  handler?: boolean
}

export type IRPropsStatic =
  Array<IRProp>

export type IRSlotDynamic =
  IRSlotDynamicBasic | IRSlotDynamicLoop | IRSlotDynamicConditional

export interface IRSlotDynamicBasic {
  slotType: IRSlotType.DYNAMIC
  name: SimpleExpressionNode
  fn: BlockIRNode
  loop?: IRFor
}

export interface IRSlotDynamicConditional {
  slotType: IRSlotType.CONDITIONAL
  condition: SimpleExpressionNode
  positive: IRSlotDynamicBasic
  negative?: IRSlotDynamicBasic | IRSlotDynamicConditional
}

export interface IRSlotDynamicLoop {
  slotType: IRSlotType.LOOP
  name: SimpleExpressionNode
  fn: BlockIRNode
  loop: IRFor
}

export type IRSlots =
  IRSlotsStatic | IRSlotDynamic | IRSlotsExpression

export interface IRSlotsExpression {
  slotType: IRSlotType.EXPRESSION
  slots: SimpleExpressionNode
}

export interface IRSlotsStatic {
  slotType: IRSlotType.STATIC
  slots: Record<string, BlockIRNode>
}

export declare const enum IRSlotType {
  STATIC = 0,
  DYNAMIC = 1,
  LOOP = 2,
  CONDITIONAL = 3,
  EXPRESSION = 4
}

export declare function isBigIntLiteral(node?: import('oxc-parser').Node | undefined | null): node is import('oxc-parser').BigIntLiteral

export declare function isBlockOperation(op: OperationNode): op is InsertionStateTypes

export declare function isConstantExpression(exp: SimpleExpressionNode): boolean

export declare function isConstantNode(node?: object | undefined | null): boolean

export declare function isEmptyText(node: object): boolean

export declare function isJSXComponent(node: import('oxc-parser').Node): boolean

export declare function isMemberExpression(exp: SimpleExpressionNode): boolean

export declare function isNumericLiteral(node?: import('oxc-parser').Node | undefined | null): node is import('oxc-parser').NumericLiteral

export declare function isStringLiteral(node?: import('oxc-parser').Node | undefined | null): node is import('oxc-parser').StringLiteral

export const locStub: SourceLocation

export interface Modifiers {
  options: Array<string>
  keys: Array<string>
  nonKeys: Array<string>
}

export type OperationNode =
  IfIRNode | ForIRNode | SetTextIRNode | SetPropIRNode | SetDynamicPropsIRNode | SetDynamicEventsIRNode | SetNodesIRNode | SetEventIRNode | SetHtmlIRNode | SetTemplateRefIRNode | CreateNodesIRNode | InsertNodeIRNode | PrependNodeIRNode | DirectiveIRNode | CreateComponentIRNode | DeclareOldRefIRNode | SlotOutletIRNode | GetTextChildIRNode

export interface PrependNodeIRNode {
  type: IRNodeTypes.PREPEND_NODE
  elements: Array<number>
  parent: number
}

export interface PropsResult {
  dynamic: boolean
  props: Array<IRProps> | IRPropsStatic
}

export declare function resolveJSXText(node: import('oxc-parser').JSXText): string

export interface RootIRNode {
  type: IRNodeTypes
  node: object
  source: string
  templates: Array<string>
  rootTemplateIndex?: number
  component: Set<string>
  directive: Set<string>
  block: BlockIRNode
  hasTemplateRef: boolean
}

export interface SetDynamicEventsIRNode {
  type: IRNodeTypes.SET_DYNAMIC_EVENTS
  element: number
  value: SimpleExpressionNode
}

export interface SetDynamicPropsIRNode {
  type: IRNodeTypes.SET_DYNAMIC_PROPS
  element: number
  props: Array<IRProps>
  root: boolean
}

export interface SetEventIRNode {
  type: IRNodeTypes.SET_EVENT
  element: number
  key: SimpleExpressionNode
  value?: SimpleExpressionNode
  modifiers: Modifiers
  keyOverride?: [string, string]
  delegate: boolean
  effect: boolean
}

export interface SetHtmlIRNode {
  type: IRNodeTypes.SET_HTML
  element: number
  value: SimpleExpressionNode
}

export interface SetNodesIRNode {
  type: IRNodeTypes.SET_NODES
  element: number
  once: boolean
  values: Array<SimpleExpressionNode>
  generated?: boolean
}

export interface SetPropIRNode {
  type: IRNodeTypes.SET_PROP
  element: number
  prop: IRProp
  root: boolean
  tag: string
}

export interface SetTemplateRefIRNode {
  type: IRNodeTypes.SET_TEMPLATE_REF
  element: number
  value: SimpleExpressionNode
  refFor: boolean
  effect: boolean
}

export interface SetTextIRNode {
  type: IRNodeTypes.SET_TEXT
  element: number
  values: Array<SimpleExpressionNode>
  generated?: boolean
}

export interface SimpleExpressionNode {
  content: string
  isStatic: boolean
  loc?: SourceLocation
  ast?: import('oxc-parser').Node
}

export interface SlotOutletIRNode {
  type: IRNodeTypes.SLOT_OUTLET_NODE
}

export type SourceLocation =
  [number, number]

export declare function transform(node: object, options: TransformOptions): RootIRNode

export interface TransformOptions {
  source: string
  templates: Array<string>
  /** * Whether to compile components to createComponentWithFallback.
   * @default false
   */
  withFallback: boolean
  /** * Indicates that transforms and codegen should try to output valid TS code
   */
  isTs: boolean
  /** * Separate option for end users to extend the native elements list
   */
  isCustomElement: (arg: string) => boolean
  onError: (arg: object) => void
  /** * Generate source map?
   * @default false
   */
  sourceMap: boolean
  /** * Filename for source map generation.
   * Also used for self-recursive reference in templates
   * @default 'index.jsx'
   */
  filename: string
}

export const TS_NODE_TYPES: string[]

export declare function unwrapTSNode(node: import('oxc-parser').Node): import('oxc-parser').Node
