/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare const enum _DynamicFlag {
  NONE = 0,
  REFERENCED = 1,
  NON_TEMPLATE = 2,
  INSERT = 4
}

export interface BaseIRNode {
  type: IRNodeTypes
}

export interface BlockIRNode {
  type: IRNodeTypes
  node?: object
  dynamic: IRDynamicInfo
  tempId: number
  effect: Array<IREffect>
  operation: Array<OperationNode>
  returns: Array<number>
  props?: SimpleExpressionNode
}

export declare function camelize(str: string): string

export type CodeFragment =
  FragmentSymbol | Fragment | string | undefined | null

export type CodeFragmentDelimiters =
  [CodeFragments, CodeFragments, CodeFragments, string | undefined | null]

export type CodeFragments =
  FragmentSymbol | Fragment | string | undefined | null | Array<CodeFragment>

export interface CodegenOptions {
  /** * Generate source map?
   * @default false
   */
  sourceMap?: boolean
  /** * Filename for source map generation.
   * Also used for self-recursive reference in templates
   * @default 'index.jsx'
   */
  filename?: string
  templates?: Array<string>
}

export interface CompilerError extends SyntaxError {
  code: number
  loc?: SourceLocation
}

export interface CreateComponentIRNode {
  type: IRNodeTypes.CREATE_COMPONENT_NODE
  id: number
  tag: string
  props: Array<IRProps>
  slots: Array<IRSlots>
  asset: boolean
  root: boolean
  once: boolean
  dynamic?: SimpleExpressionNode
  parent?: number
  anchor?: number
}

export interface CreateNodesIRNode {
  type: IRNodeTypes.CREATE_NODES
  id: number
  once: boolean
  values: Array<SimpleExpressionNode>
}

export declare function createSimpleExpression(content: string, isStatic?: boolean | undefined | null, ast?: object | undefined | null, loc?: SourceLocation | undefined | null): SimpleExpressionNode

export interface DeclareOldRefIRNode {
  type: IRNodeTypes.DECLARE_OLD_REF
  id: number
}

export interface DirectiveIRNode {
  type: IRNodeTypes.DIRECTIVE
  element: number
  dir: DirectiveNode
  name: string
  builtin?: boolean
  asset?: boolean
  modelType?: 'text' | 'dynamic' | 'radio' | 'checkbox' | 'select'
}

export interface DirectiveNode {
  name: string
  exp?: SimpleExpressionNode
  arg?: SimpleExpressionNode
  modifiers: Array<SimpleExpressionNode>
  loc?: SourceLocation
}

export interface DirectiveTransformResult {
  key: SimpleExpressionNode
  value: SimpleExpressionNode
  modifier?: '.' | '^'
  runtimeCamelize?: boolean
  handler?: boolean
  handlerModifiers?: Modifiers
  model?: boolean
  modelModifiers?: Array<string>
}

export const EMPTY_EXPRESSION: SimpleExpressionNode

export declare const enum ErrorCodes {
  X_V_IF_NO_EXPRESSION = 28,
  X_V_ELSE_NO_ADJACENT_IF = 30,
  X_V_FOR_NO_EXPRESSION = 31,
  X_V_FOR_MALFORMED_EXPRESSION = 32,
  X_V_ON_NO_EXPRESSION = 35,
  X_V_SLOT_MIXED_SLOT_USAGE = 37,
  X_V_SLOT_DUPLICATE_SLOT_NAMES = 38,
  X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN = 39,
  X_V_SLOT_MISPLACED = 40,
  X_V_MODEL_NO_EXPRESSION = 41,
  X_V_MODEL_MALFORMED_EXPRESSION = 42,
  X_V_HTML_NO_EXPRESSION = 53,
  X_V_HTML_WITH_CHILDREN = 54,
  X_V_TEXT_NO_EXPRESSION = 55,
  X_V_TEXT_WITH_CHILDREN = 56,
  X_V_MODEL_ON_INVALID_ELEMENT = 57,
  X_V_MODEL_ARG_ON_ELEMENT = 58,
  X_V_MODEL_ON_FILE_INPUT_ELEMENT = 59,
  X_V_MODEL_UNNECESSARY_VALUE = 60,
  X_V_SHOW_NO_EXPRESSION = 61
}

export declare function extractIdentifiers(node: object, identifiers: Array<object>): Array<object>

export interface ForIRNode {
  source: SimpleExpressionNode
  value?: SimpleExpressionNode
  key?: SimpleExpressionNode
  index?: SimpleExpressionNode
  type: IRNodeTypes.FOR
  id: number
  keyProp?: SimpleExpressionNode
  render: BlockIRNode
  once: boolean
  component: boolean
  onlyChild: boolean
  parent?: number
  anchor?: number
}

export type Fragment =
  [string, NewlineType, SourceLocation | undefined | null, string | undefined | null]

export declare const enum FragmentSymbol {
  Newline = 1,
  IndentStart = 2,
  IndentEnd = 3
}

export declare function genBlock(oper: BlockIRNode, context: object, args: Array<CodeFragment>, root: boolean): Array<CodeFragment>

export declare function genCall(node: string | [string, CodeFragment | undefined | null], frags: Array<CodeFragments>): Array<CodeFragment>

export declare function genExpression(node: SimpleExpressionNode, context: object, assignment?: string | undefined | null, needWrap?: boolean | undefined | null): Array<CodeFragment>

export declare function genInsertNode(oper: InsertNodeIRNode, context: object): Array<CodeFragment>

export declare function genMulti([left, right, seg, placeholder]: CodeFragmentDelimiters, frags: Array<CodeFragments>): Array<CodeFragment>

export declare function getDelimitersArray(): CodeFragmentDelimiters

export declare function getDelimitersArrayNewline(): CodeFragmentDelimiters

export declare function getDelimitersObject(): CodeFragmentDelimiters

export declare function getDelimitersObjectNewline(): CodeFragmentDelimiters

export declare function getExpression(node: import('oxc-parser').Node): import('oxc-parser').Node

export declare function getLiteralExpressionValue(exp: SimpleExpressionNode): string | null

export interface GetTextChildIRNode {
  type: IRNodeTypes.GET_TEXT_CHILD
  parent: number
}

export declare function getTextLikeValue(node: import('oxc-parser').Node, excludeNumber?: boolean | undefined | null): string | null

export interface IfIRNode {
  type: IRNodeTypes.IF
  id: number
  condition: SimpleExpressionNode
  positive: BlockIRNode
  negative?: BlockIRNode | IfIRNode
  once?: boolean
  parent?: number
  anchor?: number
}

export type InsertionStateTypes =
  IfIRNode | ForIRNode | CreateComponentIRNode

export interface InsertNodeIRNode {
  type: IRNodeTypes.INSERT_NODE
  elements: Array<number>
  parent: number
  anchor?: number
}

export interface IRDynamicInfo {
  id?: number
  flags: number
  anchor?: number
  children: Array<IRDynamicInfo>
  template?: number
  hasDynamicChild?: boolean
  operation?: OperationNode | null
}

export declare const enum IRDynamicPropsKind {
  EXPRESSION = 0,
  ATTRIBUTE = 1
}

export interface IREffect {
  expressions: Array<SimpleExpressionNode>
  operations: Array<OperationNode>
}

export interface IRFor {
  source?: SimpleExpressionNode
  value?: SimpleExpressionNode
  key?: SimpleExpressionNode
  index?: SimpleExpressionNode
}

export declare const enum IRNodeTypes {
  ROOT = 'ROOT',
  BLOCK = 'BLOCK',
  SET_PROP = 'SET_PROP',
  SET_DYNAMIC_PROPS = 'SET_DYNAMIC_PROPS',
  SET_TEXT = 'SET_TEXT',
  SET_EVENT = 'SET_EVENT',
  SET_DYNAMIC_EVENTS = 'SET_DYNAMIC_EVENTS',
  SET_HTML = 'SET_HTML',
  SET_TEMPLATE_REF = 'SET_TEMPLATE_REF',
  INSERT_NODE = 'INSERT_NODE',
  CREATE_COMPONENT_NODE = 'CREATE_COMPONENT_NODE',
  DIRECTIVE = 'DIRECTIVE',
  DECLARE_OLD_REF = 'DECLARE_OLD_REF',
  IF = 'IF',
  FOR = 'FOR',
  GET_TEXT_CHILD = 'GET_TEXT_CHILD',
  CREATE_NODES = 'CREATE_NODES',
  SET_NODES = 'SET_NODES'
}

export interface IRProp {
  key: SimpleExpressionNode
  modifier?: '.' | '^'
  runtimeCamelize?: boolean
  handler?: boolean
  handlerModifiers?: Modifiers
  model?: boolean
  modelModifiers?: Array<string>
  values: Array<SimpleExpressionNode>
}

export type IRProps =
  IRPropsStatic | IRPropsDynamicAttribute | IRPropsDynamicExpression

export interface IRPropsDynamicAttribute {
  key: SimpleExpressionNode
  modifier?: '.' | '^'
  runtimeCamelize?: boolean
  handler?: boolean
  handlerModifiers?: Modifiers
  model?: boolean
  modelModifiers?: Array<string>
  values: Array<SimpleExpressionNode>
  kind: IRDynamicPropsKind.ATTRIBUTE
}

export interface IRPropsDynamicExpression {
  kind: IRDynamicPropsKind.EXPRESSION
  value: SimpleExpressionNode
  handler?: boolean
}

export type IRPropsStatic =
  Array<IRProp>

export type IRSlotDynamic =
  IRSlotDynamicBasic | IRSlotDynamicLoop | IRSlotDynamicConditional

export interface IRSlotDynamicBasic {
  slotType: IRSlotType.DYNAMIC
  name: SimpleExpressionNode
  fn: BlockIRNode
  loop?: IRFor
}

export interface IRSlotDynamicConditional {
  slotType: IRSlotType.CONDITIONAL
  condition: SimpleExpressionNode
  positive: IRSlotDynamicBasic
  negative?: IRSlotDynamicBasic | IRSlotDynamicConditional
}

export interface IRSlotDynamicLoop {
  slotType: IRSlotType.LOOP
  name: SimpleExpressionNode
  fn: BlockIRNode
  loop: IRFor
}

export type IRSlots =
  IRSlotsStatic | IRSlotDynamic | IRSlotsExpression

export interface IRSlotsExpression {
  slotType: IRSlotType.EXPRESSION
  slots: SimpleExpressionNode
}

export interface IRSlotsStatic {
  slotType: IRSlotType.STATIC
  slots: Record<string, BlockIRNode>
}

export declare const enum IRSlotType {
  STATIC = 0,
  DYNAMIC = 1,
  LOOP = 2,
  CONDITIONAL = 3,
  EXPRESSION = 4
}

export declare function isBigIntLiteral(node?: import('oxc-parser').Node | undefined | null): node is import('oxc-parser').BigIntLiteral

export declare function isBlockOperation(op: OperationNode): op is InsertionStateTypes

export declare function isConstantExpression(exp: SimpleExpressionNode): boolean

export declare function isConstantNode(node?: object | undefined | null): boolean

export declare function isEmptyText(node: object): boolean

export declare function isFnExpression(exp: SimpleExpressionNode): boolean

export declare function isForStatement(node: object): boolean

/** * Checks if the given node is a function type.
 *
 * @param node - The node to check.
 * @returns True if the node is a function type, false otherwise.
 */
export declare function isFunctionType(node: object): boolean

export declare function isIdentifier(node: object): boolean

export declare function isInDestructureAssignment(parent: object | undefined | null, parentStack: Array<object>): boolean

export declare function isJSXComponent(node: import('oxc-parser').Node): boolean

export declare function isMemberExpression(exp: SimpleExpressionNode): boolean

export declare function isNumericLiteral(node?: import('oxc-parser').Node | undefined | null): node is import('oxc-parser').NumericLiteral

export declare function isReferenced(node: object, parent: object, grandparent?: object | undefined | null): boolean

export declare function isReferencedIdentifier(id: object, parent: object | undefined | null, parentStack: Array<object>): boolean

export declare function isSimpleIdentifier(name: string): boolean

export declare function isStaticProperty(node: object): boolean

export declare function isStringLiteral(node?: import('oxc-parser').Node | undefined | null): node is import('oxc-parser').StringLiteral

export const locStub: SourceLocation

export interface Modifiers {
  options: Array<string>
  keys: Array<string>
  nonKeys: Array<string>
}

export declare const enum NewlineType {
  /** Start with `
  `  */
  Start = 0,
  /** Ends with `
  `  */
  End = -1,
  /** No `
  ` included  */
  None = -2,
  /** Don't know, calc it  */
  Unknown = -3
}

export type OperationNode =
  IfIRNode | ForIRNode | SetTextIRNode | SetPropIRNode | SetDynamicPropsIRNode | SetDynamicEventsIRNode | SetNodesIRNode | SetEventIRNode | SetHtmlIRNode | SetTemplateRefIRNode | CreateNodesIRNode | InsertNodeIRNode | DirectiveIRNode | CreateComponentIRNode | DeclareOldRefIRNode | GetTextChildIRNode

export interface PropsResult {
  dynamic: boolean
  props: Array<IRProps> | IRPropsStatic
}

export declare function resolveJSXText(node: import('oxc-parser').JSXText): string

export interface RootIRNode {
  type: IRNodeTypes
  node: object
  source: string
  templates: Array<string>
  rootTemplateIndex?: number
  component: Set<string>
  directive: Set<string>
  block: BlockIRNode
  hasTemplateRef: boolean
}

export interface SetDynamicEventsIRNode {
  type: IRNodeTypes.SET_DYNAMIC_EVENTS
  element: number
  value: SimpleExpressionNode
}

export interface SetDynamicPropsIRNode {
  type: IRNodeTypes.SET_DYNAMIC_PROPS
  element: number
  props: Array<IRProps>
  root: boolean
}

export interface SetEventIRNode {
  type: IRNodeTypes.SET_EVENT
  element: number
  key: SimpleExpressionNode
  value?: SimpleExpressionNode
  modifiers: Modifiers
  keyOverride?: [string, string]
  delegate: boolean
  effect: boolean
}

export interface SetHtmlIRNode {
  type: IRNodeTypes.SET_HTML
  element: number
  value: SimpleExpressionNode
}

export interface SetNodesIRNode {
  type: IRNodeTypes.SET_NODES
  element: number
  once: boolean
  values: Array<SimpleExpressionNode>
  generated?: boolean
}

export interface SetPropIRNode {
  type: IRNodeTypes.SET_PROP
  element: number
  prop: IRProp
  root: boolean
  tag: string
}

export interface SetTemplateRefIRNode {
  type: IRNodeTypes.SET_TEMPLATE_REF
  element: number
  value: SimpleExpressionNode
  refFor: boolean
  effect: boolean
}

export interface SetTextIRNode {
  type: IRNodeTypes.SET_TEXT
  element: number
  values: Array<SimpleExpressionNode>
  generated?: boolean
}

export interface SimpleExpressionNode {
  content: string
  isStatic: boolean
  loc?: SourceLocation
  ast?: import('oxc-parser').Node
}

export type SourceLocation =
  [number, number]

export type SyncHandler<T = object> =
  (arg0: T, arg1?: T | undefined | null, arg2?: string | undefined | null, arg3?: number | undefined | null) => boolean | object | null

export declare function toValidAssetId(name: string, type: string): string

export declare function transform(node: object, options: TransformOptions): RootIRNode

export interface TransformOptions {
  source: string
  templates: Array<string>
  /** * Whether to compile components to createComponentWithFallback.
   * @default false
   */
  withFallback: boolean
  /** * Indicates that transforms and codegen should try to output valid TS code
   */
  isTS: boolean
  /** * Separate option for end users to extend the native elements list
   */
  isCustomElement: (arg: string) => boolean
  onError: (arg: object) => void
  /** * Generate source map?
   * @default false
   */
  sourceMap: boolean
  /** * Filename for source map generation.
   * Also used for self-recursive reference in templates
   * @default 'index.jsx'
   */
  filename: string
}

export const TS_NODE_TYPES: string[]

export declare function unwrapTSNode(node: import('oxc-parser').Node): import('oxc-parser').Node

export declare function walk(ast: object, options: WalkOptions): object | null

/** * Modified from https://github.com/vuejs/core/blob/main/packages/compiler-core/src/babelUtils.ts
 * To support browser environments and JSX.
 *
 * https://github.com/vuejs/core/blob/main/LICENSE
 *
 * Return value indicates whether the AST walked can be a constant
 */
export declare function walkIdentifiers(root: object, onIdentifier: any, includeAll?: boolean | undefined | null, parentStack?: Array<object> | undefined | null, knownIds?: Record<string, number> | undefined | null): void

export interface WalkOptions {
  enter?: SyncHandler<object>
  leave?: SyncHandler<object>
}
